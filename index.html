<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MiniPlatform + Editor JS (Sandboxed) — Demo</title>
<style>
  html,body{height:100%;margin:0;font-family:Inter, system-ui, Arial;background:#0b1220;color:#eaeef6}
  #container{position:relative;width:100%;height:100%;overflow:hidden}
  canvas{display:block}

  /* UI panels */
  .panel{position:absolute;background:rgba(0,0,0,0.5);backdrop-filter: blur(6px);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.04);font-size:13px}
  #leftPanel{left:10px;top:10px;width:260px;max-height:calc(100% - 20px);overflow:auto}
  #rightPanel{right:10px;top:10px;width:360px;max-height:calc(100% - 20px);overflow:auto}
  #bottomPanel{left:10px;right:10px;bottom:10px;height:140px}

  input,select,button,textarea{font-family:inherit;font-size:13px}
  #playerList{margin-top:8px;max-height:140px;overflow:auto}
  .scriptItem{padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.03);display:flex;justify-content:space-between;align-items:center}
  .small{font-size:12px;opacity:0.8}
  #editor{width:100%;height:240px;background:#0f1722;color:#dbeafe;border:1px solid rgba(255,255,255,0.04);padding:8px;border-radius:6px;resize:vertical}

  /* joystick and buttons (mobile) */
  .joystick { position: absolute; left:18px; bottom:18px; width:120px; height:120px; border-radius:50%; background: rgba(255,255,255,0.04); pointer-events: auto; touch-action:none }
  .stick { position:absolute; left:50%; top:50%; width:56px; height:56px; margin:-28px 0 0 -28px; border-radius:50%; background: rgba(255,255,255,0.12) }
  .btn { position:absolute; right:18px; bottom:18px; width:64px;height:64px;border-radius:12px;background:rgba(255,255,255,0.06);display:flex;align-items:center;justify-content:center;pointer-events:auto; }
  .btn:active{transform:scale(0.98)}

  @media(min-width:900px){
    .joystick,.btn{display:none}
  }
</style>
</head>
<body>
<div id="container">
  <!-- three.js canvas injected by script -->

  <!-- Left: Connection & players -->
  <div id="leftPanel" class="panel">
    <div><strong>MiniPlatform</strong> — Demo</div>
    <div style="margin-top:8px">
      <div>Nombre: <input id="nameInput" placeholder="Tu nombre" style="width:130px"/></div>
      <div style="margin-top:6px">
        <button id="connectBtn">Conectar</button>
        <button id="disconnectBtn">Desconectar</button>
      </div>
      <div class="small" style="margin-top:6px">Estado: <span id="status">desconectado</span></div>
    </div>

    <hr style="opacity:0.08"/>

    <div><strong>Jugadores</strong></div>
    <div id="playerList" class="small"></div>

    <hr style="opacity:0.08"/>

    <div><strong>Scripts publicados</strong></div>
    <div id="scriptList" style="margin-top:6px"></div>

  </div>

  <!-- Right: Editor -->
  <div id="rightPanel" class="panel">
    <div><strong>Editor JS (sandboxed)</strong></div>
    <div class="small" style="margin-top:6px">Escribe código que use la API limitada: <code>api.log(msg)</code>, <code>api.spawnBox(x,y,z)</code>, <code>api.setPlayerSpeed(n)</code></div>

    <textarea id="editor" placeholder="// Ejemplo:
// api.log('hola desde script');
// api.spawnBox( Math.random()*6-3, 1, Math.random()*6-3 );" spellcheck="false"></textarea>

    <div style="margin-top:8px;display:flex;gap:8px">
      <button id="runLocalBtn">Ejecutar local (preview)</button>
      <button id="saveScriptBtn">Guardar en Firebase</button>
      <input id="scriptTitle" placeholder="Título" style="flex:1"/>
    </div>

    <div style="margin-top:10px"><strong>Sandbox preview</strong></div>
    <iframe id="sandboxFrame" style="width:100%;height:200px;border-radius:6px;border:1px solid rgba(255,255,255,0.06)" sandbox="allow-scripts"></iframe>

    <div style="margin-top:6px" class="small">Nota: scripts ejecutados en sandbox no tienen acceso al DOM principal ni a Firebase. Solo la API permitida.</div>
  </div>

  <!-- Bottom: small controls + joystick -->
  <div id="bottomPanel" class="panel" style="left:10px;right:10px;bottom:10px;display:flex;align-items:center;gap:12px">
    <div>Controles: <span class="small">Desktop: WASD / mouse; Móvil: joystick + botón</span></div>
    <div style="flex:1"></div>
    <div class="small">FPS: <span id="fps">-</span></div>
  </div>

  <div class="joystick" id="joyArea"><div class="stick" id="stick"></div></div>
  <div class="btn" id="jumpBtn">Saltar</div>
</div>

<!-- libs -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.155.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

<script>
/* ======================
   FIREBASE (Realtime DB)
   ====================== */
const firebaseConfig = {
  apiKey: "AIzaSyCFQ_geG0HIv2EZ-bfKc97TJNtf2sdqPzc",
  authDomain: "clack-koder.firebaseapp.com",
  databaseURL: "https://clack-koder-default-rtdb.firebaseio.com",
  projectId: "clack-koder",
  storageBucket: "clack-koder.firebasestorage.app",
  messagingSenderId: "478151254938",
  appId: "1:478151254938:web:e2c00e3a5426bd192b9023",
  measurementId: "G-P29ME5Z3S1"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();

let localUID = null;

/* Conexión/Desconexión anónima */
document.getElementById('connectBtn').addEventListener('click', async ()=>{
  const name = document.getElementById('nameInput').value || ('Player' + Math.floor(Math.random()*9000)+1000);
  try{
    const cred = await auth.signInAnonymously();
    localUID = cred.user.uid;
    await db.ref('players/' + localUID).set({ name, x:0,y:0,z:0, ry:0, updated: firebase.database.ServerValue.TIMESTAMP});
    db.ref('players/' + localUID).onDisconnect().remove();
    document.getElementById('status').innerText = 'conectado: ' + localUID;
    startPlayersListener();
  }catch(e){ console.error(e); document.getElementById('status').innerText = 'error'; }
});
document.getElementById('disconnectBtn').addEventListener('click', async ()=>{
  if(localUID){ await db.ref('players/' + localUID).remove().catch(()=>{}); await auth.signOut(); localUID = null; document.getElementById('status').innerText='desconectado'; stopPlayersListener(); }
});

/* ======================
   THREE.JS: escena base
   ====================== */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x8fbcd4);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0,6,10);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

// lights
const hemi = new THREE.HemisphereLight(0xffffff,0x444444,0.8); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(10,20,10); scene.add(dir);

// ground
const ground = new THREE.Mesh(new THREE.PlaneGeometry(200,200), new THREE.MeshStandardMaterial({color:0x2f7f46}));
ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

// simple boxes array (for scripts to spawn)
const spawnedBoxes = [];

/* player */
function makePlayerMesh(color=0x00aaff){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1.6,12), new THREE.MeshStandardMaterial({color}));
  body.position.y = 0.8; g.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.45,12,12), new THREE.MeshStandardMaterial({color:0xf2c9b6}));
  head.position.y = 1.7; g.add(head);
  return g;
}
const localPlayer = { mesh: makePlayerMesh(0x00ddff), pos: new THREE.Vector3(0,0,0), vel: new THREE.Vector3(0,0,0), rotY:0, speed:4, onGround:true };
scene.add(localPlayer.mesh);

/* camera follow */
function updateCamera(){ const behind = new THREE.Vector3(0,2.2,6).applyAxisAngle(new THREE.Vector3(0,1,0), localPlayer.rotY); const camPos = localPlayer.mesh.position.clone().add(behind); camera.position.lerp(camPos,0.12); camera.lookAt(localPlayer.mesh.position.clone().add(new THREE.Vector3(0,1.2,0))); }

/* simple physics */
const GRAV = -20;
function physicsStep(dt){
  if(!localPlayer.onGround) localPlayer.vel.y += GRAV * dt;
  localPlayer.mesh.position.add(localPlayer.vel.clone().multiplyScalar(dt));
  if(localPlayer.mesh.position.y <= 0){ localPlayer.mesh.position.y = 0; localPlayer.vel.y = 0; localPlayer.onGround = true; } else localPlayer.onGround = false;
}

/* controls (reuse joystick and keys) */
let input = {x:0,z:0,jump:false};
const stickEl = document.getElementById('stick'), joyArea = document.getElementById('joyArea');
let joyCenter = {x:0,y:0}, touchId=null;
function startJoy(){ const r=joyArea.getBoundingClientRect(); joyCenter={x:r.left+r.width/2,y:r.top+r.height/2}; } startJoy();
addEventListener('resize', startJoy);
joyArea.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.changedTouches[0]; touchId=t.identifier; updateStickFromTouch(t); });
joyArea.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches) if(t.identifier===touchId) { updateStickFromTouch(t); break; }});
joyArea.addEventListener('touchend', e=>{ e.preventDefault(); for(const t of e.changedTouches) if(t.identifier===touchId){ touchId=null; resetStick(); break; }});
function updateStickFromTouch(t){ const dx=t.clientX-joyCenter.x, dy=t.clientY-joyCenter.y, max=40; const nx=Math.max(-1,Math.min(1,dx/max)), ny=Math.max(-1,Math.min(1,dy/max)); input.x = nx; input.z = -ny; stickEl.style.transform = `translate(${nx*30}px, ${ny*30}px)`; }
function resetStick(){ input.x=0; input.z=0; stickEl.style.transform='translate(0,0)'; }
document.getElementById('jumpBtn').addEventListener('touchstart', e=>{ e.preventDefault(); input.jump=true; setTimeout(()=>input.jump=false,150); });

const keys = {}; window.addEventListener('keydown', e=>keys[e.key.toLowerCase()]=true); window.addEventListener('keyup', e=>keys[e.key.toLowerCase()]=false);
renderer.domElement.addEventListener('click', ()=> { if(innerWidth>=900) renderer.domElement.requestPointerLock?.(); });
let isPointerLocked=false; document.addEventListener('pointerlockchange', ()=> isPointerLocked = !!document.pointerLockElement);
document.addEventListener('mousemove', e=>{ if(isPointerLocked){ localPlayer.rotY -= e.movementX * 0.002; } });

// game loop
let lastTime = performance.now(), fpsCounter={last:performance.now(),frames:0};
function loop(t){
  const dt = Math.min(0.05,(t-lastTime)/1000); lastTime=t;

  if(innerWidth>=900){
    const f = (keys['w']||keys['arrowup'])?1:0, b=(keys['s']||keys['arrowdown'])?1:0, l=(keys['a']||keys['arrowleft'])?1:0, r=(keys['d']||keys['arrowright'])?1:0;
    input.z = f - b; input.x = r - l; input.jump = !!keys[' '];
  }

  const moveDir = new THREE.Vector3(input.x,0,input.z);
  if(moveDir.lengthSq()>0.001){
    moveDir.normalize(); moveDir.applyAxisAngle(new THREE.Vector3(0,1,0), localPlayer.rotY);
    const horiz = new THREE.Vector3(moveDir.x,0,moveDir.z).multiplyScalar(localPlayer.speed);
    localPlayer.vel.x = THREE.MathUtils.lerp(localPlayer.vel.x, horiz.x, 0.12);
    localPlayer.vel.z = THREE.MathUtils.lerp(localPlayer.vel.z, horiz.z, 0.12);
    const targetAngle = Math.atan2(-moveDir.z, moveDir.x) + Math.PI/2;
    localPlayer.rotY = THREE.MathUtils.lerpAngle(localPlayer.rotY, targetAngle, 0.16);
  } else {
    localPlayer.vel.x = THREE.MathUtils.lerp(localPlayer.vel.x, 0, 0.18);
    localPlayer.vel.z = THREE.MathUtils.lerp(localPlayer.vel.z, 0, 0.18);
  }

  if(input.jump && localPlayer.onGround){ localPlayer.vel.y = 6; localPlayer.onGround = false; }

  physicsStep(dt);
  localPlayer.mesh.rotation.y = localPlayer.rotY;
  updateCamera();

  renderer.render(scene, camera);

  // FPS
  fpsCounter.frames++; if(performance.now()-fpsCounter.last>500){ document.getElementById('fps').innerText = Math.round(fpsCounter.frames / ((performance.now()-fpsCounter.last)/1000)); fpsCounter.last = performance.now(); fpsCounter.frames = 0; }

  // broadcast to firebase occasionally
  if(localUID && (!localPlayer._lastSent || performance.now()-localPlayer._lastSent>120)){
    localPlayer._lastSent = performance.now();
    db.ref('players/' + localUID).update({ x: localPlayer.mesh.position.x, y: localPlayer.mesh.position.y, z: localPlayer.mesh.position.z, ry: localPlayer.rotY, updated: firebase.database.ServerValue.TIMESTAMP }).catch(()=>{});
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* ======================
   Multiplayer listeners
   ====================== */
const players = {}; // uid -> mesh
let playersListener = null;
function startPlayersListener(){
  if(playersListener) return;
  playersListener = db.ref('players').on('value', snap=>{
    const data = snap.val() || {};
    // create/update
    for(const uid in data){
      if(uid === localUID) continue;
      const p = data[uid];
      if(!players[uid]){ const m = makePlayerMesh(0xffaa00); scene.add(m); players[uid] = {mesh:m, last:Date.now()}; }
      const m = players[uid].mesh;
      m.position.x = THREE.MathUtils.lerp(m.position.x, p.x || 0, 0.18);
      m.position.y = THREE.MathUtils.lerp(m.position.y, p.y || 0, 0.12);
      m.position.z = THREE.MathUtils.lerp(m.position.z, p.z || 0, 0.18);
      if(typeof p.ry==='number') m.rotation.y = THREE.MathUtils.lerp(m.rotation.y, p.ry, 0.12);
      players[uid].last = Date.now();
    }
    // remove missing
    for(const uid in players) if(!data[uid]){ scene.remove(players[uid].mesh); delete players[uid]; }
    // update UI list
    const list = document.getElementById('playerList'); list.innerHTML = '';
    for(const uid in data){ const el = document.createElement('div'); el.innerText = (uid===localUID?'(TÚ) ':'') + (data[uid].name || uid); el.className='small'; list.appendChild(el); }
  });
}
function stopPlayersListener(){ if(playersListener){ db.ref('players').off('value', playersListener); playersListener = null; for(const uid in players){ scene.remove(players[uid].mesh); } Object.keys(players).forEach(k=>delete players[k]); } }

/* ======================
   SCRIPT: Editor, save, list, run
   ====================== */

/*
Design of sandbox:
- Scripts run inside iframe with sandbox="allow-scripts"
- The host provides a limited API via postMessage: { type:'api', id, method, args }
- Allowed methods: log, spawnBox, setPlayerSpeed
- The iframe must use `api.post(method, args)` to call host. Host checks origin and source (iframe contentWindow).
- Scripts are saved in Firebase under /scripts/{pushId} with fields: title, code, author, ts
*/

const editor = document.getElementById('editor');
const sandboxFrame = document.getElementById('sandboxFrame');
const runLocalBtn = document.getElementById('runLocalBtn');
const saveScriptBtn = document.getElementById('saveScriptBtn');
const scriptListEl = document.getElementById('scriptList');
const scriptTitleEl = document.getElementById('scriptTitle');

// Utilities to create iframe srcdoc with wrapper that exposes simple api to the user code
function makeSandboxSrcdoc(userCode){
  // wrapper code inside iframe: creates 'api' object that posts messages to parent and listens for responses.
  // We include a small helper to catch errors and send them as logs.
  const wrapper = `
  <!doctype html>
  <html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"></head>
  <body style="background:#0b1220;color:#dbeafe;font-family:monospace">
    <div id="log" style="padding:8px;font-size:12px"></div>
    <script>
      // unique id for calls
      const _origin = 'sandbox';
      function send(msg){ parent.postMessage(msg, '*'); }

      // api the user uses
      window.api = {
        post: function(method, args){
          try{
            send({type:'api', method: method, args: args || []});
          }catch(e){
            send({type:'log', level:'error', msg: 'post error: '+(e.message||e)});
          }
        },
        log: function(...a){ send({type:'log', level:'info', msg: a.map(x=>String(x)).join(' ')}); }
      };

      // safety: prevent infinite loops by providing a limited setTimeout/interval (still possible to abuse, but limited)
      // Run user code safely wrapped in try/catch
      try{
        (async function(){
          ${userCode}
        })().catch(e=>{ send({type:'log', level:'error', msg: 'runtime error: '+ (e && e.message ? e.message : e) }); });
      }catch(e){
        send({type:'log', level:'error', msg: 'exec error: '+(e && e.message ? e.message : e) });
      }

      // also show logs inside iframe UI
      window.addEventListener('message', e=>{
        try{
          const d = e.data || {};
          if(d.type === 'host_log'){
            const el = document.getElementById('log');
            const p = document.createElement('div'); p.textContent = '[host] ' + d.msg; el.appendChild(p);
          }
        }catch(_){}
      });
    <\/script>
  </body></html>
  `;
  return wrapper;
}

// Host: allowed API handlers (only these can be triggered by sandbox)
function handleSandboxMessage(event, iframeWindow){
  // Ensure message is from the expected iframe
  if(event.source !== iframeWindow) return;
  const data = event.data || {};
  if(data.type === 'api'){
    const method = String(data.method || '');
    const args = Array.isArray(data.args) ? data.args : [];
    // Whitelist methods
    if(method === 'log'){
      safeLog('[script] ' + args.map(a=>String(a)).join(' '));
    } else if(method === 'spawnBox'){
      const x = Number(args[0]||0), y = Number(args[1]||1), z = Number(args[2]||0);
      hostSpawnBox(x,y,z);
    } else if(method === 'setPlayerSpeed'){
      const n = Number(args[0]||4);
      localPlayer.speed = Math.max(0, Math.min(30, n));
      safeLog('[script] setPlayerSpeed -> ' + localPlayer.speed);
    } else {
      safeLog('[script] método no permitido: ' + method);
    }
  } else if(data.type === 'log'){
    // iframe asks to log a message
    safeLog('[iframe] ' + (data.msg || ''));
  }
}

// Host utilities
function safeLog(msg){
  console.log(msg);
  // show briefly in sandbox iframe (post to iframe)
  try{ sandboxFrame.contentWindow.postMessage({type:'host_log', msg}, '*'); }catch(e){}
}
function hostSpawnBox(x,y,z){
  const size = 0.8;
  const geo = new THREE.BoxGeometry(size,size,size);
  const mat = new THREE.MeshStandardMaterial({color:Math.random()*0xffffff});
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x,y,z); m.castShadow=true; scene.add(m);
  spawnedBoxes.push(m);
  // auto-remove after 60s to avoid pollution
  setTimeout(()=>{ scene.remove(m); }, 60*1000);
}

/* Run the code in iframe preview */
runLocalBtn.addEventListener('click', ()=>{
  const code = editor.value || '// vacío';
  sandboxFrame.srcdoc = makeSandboxSrcdoc(code);
  // listen messages once for this iframe
});

/* Save script to Firebase (requires connected user ideally) */
saveScriptBtn.addEventListener('click', async ()=>{
  const title = (scriptTitleEl.value||'Script sin título').slice(0,120);
  const code = editor.value || '';
  if(!code.trim()){ alert('El editor está vacío'); return; }
  // metadata
  const meta = { title, code, author: localUID || 'anon', ts: Date.now() };
  const newRef = db.ref('scripts').push();
  await newRef.set(meta);
  alert('Script guardado con id: ' + newRef.key);
});

/* List scripts and allow Run or Fork */
function loadScriptList(){
  db.ref('scripts').orderByChild('ts').limitToLast(50).on('value', snap=>{
    const data = snap.val() || {};
    scriptListEl.innerHTML = '';
    const arr = Object.keys(data).map(k=>({id:k, ...data[k]})).sort((a,b)=>b.ts - a.ts);
    arr.forEach(s=>{
      const div = document.createElement('div'); div.className='scriptItem';
      const left = document.createElement('div'); left.style.flex='1';
      const t = document.createElement('div'); t.innerText = s.title; t.style.fontWeight='600';
      const a = document.createElement('div'); a.innerText = 'by '+ (s.author||'anon') + ' • '+ new Date(s.ts).toLocaleString(); a.className='small';
      left.appendChild(t); left.appendChild(a);
      const right = document.createElement('div');
      const runBtn = document.createElement('button'); runBtn.innerText='Run'; runBtn.style.marginRight='6px';
      const forkBtn = document.createElement('button'); forkBtn.innerText='Fork';
      runBtn.addEventListener('click', ()=>{ sandboxFrame.srcdoc = makeSandboxSrcdoc(s.code || '// vacío'); });
      forkBtn.addEventListener('click', ()=>{ editor.value = s.code || ''; scriptTitleEl.value = s.title + ' (fork)'; window.scrollTo({top:0,behavior:'smooth'}); });
      right.appendChild(runBtn); right.appendChild(forkBtn);
      div.appendChild(left); div.appendChild(right);
      scriptListEl.appendChild(div);
    });
  });
}
loadScriptList();

/* Listen postMessage from sandbox and validate */
window.addEventListener('message', (ev)=>{
  // Ensure the iframe exists and source is its contentWindow
  const iframeWin = sandboxFrame.contentWindow;
  handleSandboxMessage(ev, iframeWin);
});

/* ======================
   Misc: cleanup, UI, double-click teleport etc.
   ====================== */
renderer.domElement.addEventListener('dblclick', ()=>{ localPlayer.mesh.position.set(Math.random()*8-4,0,Math.random()*8-4); });

window.addEventListener('beforeunload', ()=>{ if(localUID) db.ref('players/' + localUID).remove().catch(()=>{}); });

/* small helper to remove old spawned boxes */
setInterval(()=>{ if(spawnedBoxes.length > 40){ const b = spawnedBoxes.shift(); try{ scene.remove(b); }catch(e){} } }, 5000);

</script>
</body>
</html>
