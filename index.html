<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Bosque Oscuro â€” Con RÃ­os y Shock</title>
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; font-family: Arial, sans-serif; }
    #gameCanvas { width:100%; height:100%; display:block; touch-action:none; }
    .ui { position: absolute; left: 10px; top: 10px; color: #fff; z-index: 40; text-shadow: 0 0 8px rgba(0,0,0,0.9); }
    #battery { width: 200px; height: 18px; background: rgba(255,255,255,0.12); border-radius: 9px; overflow:hidden; border: 1px solid rgba(255,255,255,0.08); }
    #batteryFill { height:100%; width:100%; background: linear-gradient(90deg,#ffd24a,#ff7a4a); transition: width 0.2s linear; }
    #btnFlash { margin-top:8px; display:inline-block; padding:8px 12px; background:rgba(255,255,255,0.06); border-radius:8px; border:1px solid rgba(255,255,255,0.06); color:#fff; font-weight:600; user-select:none; }
    #message { margin-top:8px; color:#f4f4f4; font-size:13px; opacity:0.95; }
    .joystick { position: absolute; left: 12px; bottom: 12px; width: 130px; height:130px; z-index:30; touch-action:none; display:flex; align-items:center; justify-content:center; }
    .joy-base { width:120px; height:120px; border-radius:50%; background: rgba(255,255,255,0.04); border: 2px solid rgba(255,255,255,0.06); display:flex; align-items:center; justify-content:center; position:relative; }
    .joy-knob { width:56px; height:56px; border-radius:50%; background: rgba(255,255,255,0.08); transform: translate(0,0); transition: transform 0.02s linear; }
    .look-note { position:absolute; right:12px; bottom:12px; z-index:30; color:#fff; font-size:12px; opacity:0.8; }
    #darkOverlay { position:absolute; inset:0; background: radial-gradient(circle at center, rgba(0,0,0,0) 18%, rgba(0,0,0,0.85) 60%); pointer-events:none; z-index:35; opacity:0; transition: opacity 0.5s ease; }
    #tip { position:absolute; left:50%; transform:translateX(-50%); bottom:140px; color:#fff; z-index:30; font-size:13px; opacity:0.85;}
    /* Skull shock overlay */
    #shockOverlay {
      position: absolute; inset: 0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:50;
      transition: opacity 0.6s ease;
      opacity:0;
    }
    #skull {
      font-size: 10vw; /* base */
      filter: drop-shadow(0 6px 20px rgba(0,0,0,0.9));
      transform: scale(0.02);
      transition: transform 0.6s cubic-bezier(.2,.9,.3,1), opacity 0.3s ease;
      opacity:0;
      will-change: transform, opacity;
    }
    /* When shock active */
    .shock-active #gameCanvas { filter: grayscale(1) contrast(0.9) brightness(0.9); }
    .shock-active #skull { opacity:1; transform: scale(1.8); font-size: 28vw; }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui">
    <div id="battery"><div id="batteryFill"></div></div>
    <div id="btnFlash">Linterna: ON (F)</div>
    <div id="message">BaterÃ­a: <span id="batteryNights">30.0</span> noches Â· <span id="batteryText">3600</span>s</div>
  </div>

  <div id="tip">Usa joystick (izq) para moverte y arrastra a la derecha para mirar</div>

  <div class="joystick" id="joystick">
    <div class="joy-base" id="joyBase">
      <div class="joy-knob" id="joyKnob"></div>
    </div>
  </div>

  <div class="look-note">Arrastra aquÃ­ para mirar</div>
  <div id="darkOverlay"></div>

  <!-- Shock overlay (calavera) -->
  <div id="shockOverlay">
    <div id="skull">ðŸ’€</div>
  </div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>

  <script>
  // ---------- Config ----------
  const nightDuration = 120.0; // segundos que dura UNA noche
  const batteryLife = nightDuration * 30.0; // ahora dura 30 noches
  const treesCount = 180;
  const forestRadius = 120;
  const playerHeight = 1.6;
  const moveSpeed = 2.8; // m/s
  const runSpeed = 4.6;
  // RÃ­os
  const riversCount = 2; // cuÃ¡ntos rÃ­os generar
  const riverSegmentLength = 8; // distancia entre muestras
  // Shock (efecto de calavera)
  const shockIntervalMs = 30000; // cada 30s
  const shockDurationMs = 10000; // dura 10s
  // ----------------------------

  // Canvas & Renderer
  const canvas = document.getElementById('gameCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.shadowMap.enabled = false;

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000012, 0.012);

  // Camera / Player
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1200);
  camera.position.set(0, playerHeight, 0);

  // Lights
  const hemi = new THREE.HemisphereLight(0x40405a, 0x060616, 0.6);
  scene.add(hemi);

  // Moon (red)
  const moonGeo = new THREE.SphereGeometry(8, 32, 32);
  const moonMat = new THREE.MeshStandardMaterial({ color: 0x330000, emissive: 0x8b0000, emissiveIntensity: 1.8, roughness: 0.8 });
  const moonMesh = new THREE.Mesh(moonGeo, moonMat);
  moonMesh.position.set(-70, 80, -120);
  scene.add(moonMesh);

  // subtle directional light from moon (reddish)
  const moonLight = new THREE.DirectionalLight(0xffb0b0, 0.12);
  moonLight.position.copy(moonMesh.position);
  scene.add(moonLight);

  // Stars
  (function makeStars(count=900){
    const positions = new Float32Array(count * 3);
    const radius = 600;
    for (let i=0;i<count;i++){
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos((Math.random()*2)-1);
      const r = radius * (0.9 + Math.random()*0.2);
      const x = Math.sin(phi) * Math.cos(theta) * r;
      const y = Math.sin(phi) * Math.sin(theta) * r;
      const z = Math.cos(phi) * r;
      positions[i*3+0] = x;
      positions[i*3+1] = y + 80;
      positions[i*3+2] = z;
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.9, sizeAttenuation: true, depthWrite: false });
    const pts = new THREE.Points(geom, mat);
    scene.add(pts);
  })();

  // Ground
  const groundGeo = new THREE.PlaneGeometry(2000,2000,10,10);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x07100a, roughness:1 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Trees
  const treeGroup = new THREE.Group();
  scene.add(treeGroup);
  const treeCollisionSpheres = [];

  function makeTree() {
    const trunkGeo = new THREE.CylinderGeometry(0.12, 0.16, 2.0, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color:0x4a2b1b });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 1.0;

    const leavesMat = new THREE.MeshStandardMaterial({ color: 0x0c2a10, flatShading:true });
    const leaves1 = new THREE.ConeGeometry(1.2, 1.6, 8);
    const l1 = new THREE.Mesh(leaves1, leavesMat); l1.position.y = 2.0;
    const leaves2 = new THREE.ConeGeometry(0.9, 1.2, 8);
    const l2 = new THREE.Mesh(leaves2, leavesMat); l2.position.y = 2.9;

    const tree = new THREE.Group();
    tree.add(trunk, l1, l2);
    return tree;
  }

  for (let i=0;i<treesCount;i++){
    const angle = Math.random()*Math.PI*2;
    const r = Math.random()*forestRadius;
    const x = Math.cos(angle)*r;
    const z = Math.sin(angle)*r;
    if (Math.hypot(x,z) < 6) continue;
    const t = makeTree();
    t.position.set(x, 0, z);
    const s = 0.8 + Math.random()*0.9;
    t.scale.setScalar(s);
    t.rotation.y = Math.random()*Math.PI*2;
    treeGroup.add(t);
    const colRad = 0.9 * s;
    treeCollisionSpheres.push({ pos: new THREE.Vector3(x, 1.0, z), r: colRad });
  }

  // Some rocks
  for (let i=0;i<40;i++){
    const b = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.5), new THREE.MeshStandardMaterial({color:0x232323}));
    const ang = Math.random()*Math.PI*2, rr = 6 + Math.random()*forestRadius;
    b.position.set(Math.cos(ang)*rr, 0.15, Math.sin(ang)*rr);
    b.rotation.y = Math.random()*Math.PI;
    const sc = 0.5 + Math.random()*1.1; b.scale.set(sc,sc,sc);
    scene.add(b);
  }

  // ---------- RÃOS ----------
  // Helper: sample a curved path as centro del rÃ­o
  function randomRiverPath(centerX, centerZ, lengthSegments=12, bend=12) {
    const pts = [];
    let x = centerX, z = centerZ;
    let angle = Math.random()*Math.PI*2;
    for (let i=0;i<lengthSegments;i++){
      const dx = Math.cos(angle) * (riverSegmentLength * (0.7 + Math.random()*0.6));
      const dz = Math.sin(angle) * (riverSegmentLength * (0.7 + Math.random()*0.6));
      x += dx; z += dz;
      // add small random bend
      angle += (Math.random()-0.5) * (bend*0.02);
      pts.push(new THREE.Vector3(x, 0.02, z));
    }
    return pts;
  }

  // Build ribbon geometry along path (strip)
  function buildRiverMesh(pathPoints, width) {
    const segments = pathPoints.length;
    const pos = new Float32Array((segments*2) * 3);
    const uvs = new Float32Array((segments*2) * 2);
    const indices = [];

    for (let i=0;i<segments;i++){
      const p = pathPoints[i];
      const next = pathPoints[Math.min(i+1, segments-1)];
      const prev = pathPoints[Math.max(i-1, 0)];
      // tangent (approx)
      const t = new THREE.Vector3().subVectors(next, prev).normalize();
      // perpendicular in XZ plane
      const left = new THREE.Vector3(-t.z, 0, t.x).normalize();
      const half = width * (0.5 + (Math.sin(i*0.5)*0.12)); // slight width variation
      const leftPos = new THREE.Vector3().copy(p).addScaledVector(left, half);
      const rightPos = new THREE.Vector3().copy(p).addScaledVector(left, -half);

      pos[(i*2+0)*3+0] = leftPos.x; pos[(i*2+0)*3+1] = leftPos.y; pos[(i*2+0)*3+2] = leftPos.z;
      pos[(i*2+1)*3+0] = rightPos.x; pos[(i*2+1)*3+1] = rightPos.y; pos[(i*2+1)*3+2] = rightPos.z;

      const v = i / (segments-1);
      uvs[(i*2+0)*2+0] = 0; uvs[(i*2+0)*2+1] = v * 6;
      uvs[(i*2+1)*2+0] = 1; uvs[(i*2+1)*2+1] = v * 6;

      if (i < segments-1) {
        const a = i*2, b = i*2+1, c = (i+1)*2, d = (i+1)*2+1;
        indices.push(a,b,c); indices.push(b,d,c);
      }
    }

    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geom.setAttribute('uv', new THREE.BufferAttribute(uvs, 2));
    geom.setIndex(indices);
    geom.computeVertexNormals();
    // Shader material simple animado para simular movimiento del agua
    const mat = new THREE.ShaderMaterial({
      uniforms: {
        time: { value: 0.0 },
        baseColor: { value: new THREE.Color(0x223b5a) },
        highlight: { value: new THREE.Color(0x7fb3ff) },
        opacity: { value: 0.85 }
      },
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vPos;
        void main(){
          vUv = uv;
          vPos = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader: `
        uniform float time;
        uniform vec3 baseColor;
        uniform vec3 highlight;
        uniform float opacity;
        varying vec2 vUv;
        varying vec3 vPos;
        void main(){
          float wave = sin(vUv.y * 12.0 + time * 2.0) * 0.08;
          float stripe = smoothstep(0.0, 0.6, sin(vUv.x * 10.0 + time * 3.0) * 0.5 + 0.5);
          vec3 col = mix(baseColor, highlight, 0.35 * stripe + 0.25*wave);
          // darken edges
          float edge = smoothstep(0.0, 0.12, abs(vUv.x-0.5));
          col *= (1.0 - 0.25*edge);
          gl_FragColor = vec4(col, opacity);
        }
      `,
      transparent: true,
      depthWrite: false,
      side: THREE.DoubleSide
    });

    const mesh = new THREE.Mesh(geom, mat);
    mesh.receiveShadow = false;
    mesh.renderOrder = 1;
    return mesh;
  }

  // Generate several rivers
  for (let r=0;r<riversCount;r++){
    // choose a random start near center but not overlapping player
    const startX = (Math.random()-0.5) * 40;
    const startZ = (Math.random()-0.5) * 40;
    const path = randomRiverPath(startX, startZ, 14 + Math.floor(Math.random()*8));
    const width = 3 + Math.random()*4;
    const riverMesh = buildRiverMesh(path, width);
    scene.add(riverMesh);
    // add a faint dark bank (slightly darker ground) â€” optional visual
    // store river mesh to animate
    if (!window._rivers) window._rivers = [];
    window._rivers.push(riverMesh);
  }

  // ---------- Linterna ----------
  const flashlight = new THREE.SpotLight(0xfff3d9, 3.0, 22, Math.PI * 0.36, 0.9, 1);
  flashlight.position.copy(camera.position);
  flashlight.target.position.set(0, playerHeight, -1);
  scene.add(flashlight);
  scene.add(flashlight.target);

  let flashlightOn = true;
  let currentBattery = batteryLife;

  // UI Hooks
  const batteryFill = document.getElementById('batteryFill');
  const batteryText = document.getElementById('batteryText');
  const batteryNights = document.getElementById('batteryNights');
  const btnFlash = document.getElementById('btnFlash');
  const darkOverlay = document.getElementById('darkOverlay');

  function updateUI(){
    const pct = Math.max(0, Math.min(1, currentBattery / batteryLife));
    batteryFill.style.width = `${Math.round(pct*100)}%`;
    batteryText.textContent = Math.ceil(currentBattery);
    const nightsLeft = (currentBattery / nightDuration);
    batteryNights.textContent = nightsLeft.toFixed(1);
    btnFlash.textContent = `Linterna: ${flashlightOn ? 'ON (F)' : 'OFF (F)'}`;
    darkOverlay.style.opacity = flashlightOn ? (1 - pct) * 0.95 : 1.0;
  }
  updateUI();

  btnFlash.addEventListener('click', ()=>{
    flashlightOn = !flashlightOn;
    flashlight.visible = flashlightOn && currentBattery > 0;
    updateUI();
  });
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() === 'f') {
      flashlightOn = !flashlightOn;
      flashlight.visible = flashlightOn && currentBattery > 0;
      updateUI();
    }
  });

  // Movement state
  const moveState = { forward:0, right:0, running:false };
  let yaw = 0, pitch = 0;

  // Joystick
  const joyBase = document.getElementById('joyBase');
  const joyKnob = document.getElementById('joyKnob');
  const joy = { active:false, id:null, startX:0, startY:0, dx:0, dy:0 };
  function joyStart(touch){
    joy.active = true; joy.id = touch.identifier; joy.startX = touch.clientX; joy.startY = touch.clientY; joy.dx = 0; joy.dy = 0;
  }
  function joyMove(touch) {
    const max = 46;
    const dx = touch.clientX - joy.startX;
    const dy = touch.clientY - joy.startY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const clamped = Math.min(max, dist);
    const nx = dx / (dist||1) * clamped;
    const ny = dy / (dist||1) * clamped;
    joy.dx = nx; joy.dy = ny;
    joyKnob.style.transform = `translate(${nx}px, ${ny}px)`;
    moveState.forward = -ny / max;
    moveState.right = nx / max;
  }
  function joyEnd() {
    joy.active = false; joy.id = null; joy.dx = joy.dy = 0; joyKnob.style.transform = `translate(0px, 0px)`; moveState.forward = 0; moveState.right = 0;
  }

  // Touch handlers
  window.addEventListener('touchstart', (ev)=>{
    for (const t of ev.changedTouches) {
      if (t.clientX < window.innerWidth * 0.5 && !joy.active) {
        joyStart(t);
      } else {
        lookPointer.down = true; lookPointer.id = t.identifier; lookPointer.startX = t.clientX; lookPointer.startY = t.clientY;
      }
    }
  }, {passive:false});

  window.addEventListener('touchmove', (ev)=>{
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (joy.active && t.identifier === joy.id) {
        joyMove(t);
      } else if (lookPointer.id === t.identifier) {
        const dx = t.clientX - lookPointer.startX; const dy = t.clientY - lookPointer.startY;
        lookPointer.startX = t.clientX; lookPointer.startY = t.clientY;
        yaw -= dx * 0.0022; pitch -= dy * 0.0020; pitch = Math.max(-1.2, Math.min(0.65, pitch));
      }
    }
  }, {passive:false});

  window.addEventListener('touchend', (ev)=>{
    for (const t of ev.changedTouches) {
      if (joy.active && t.identifier === joy.id) joyEnd();
      if (lookPointer.id === t.identifier) { lookPointer.down = false; lookPointer.id = null; }
    }
  });

  // Look pointer for mouse
  const lookPointer = { down:false, id:null, startX:0, startY:0 };
  window.addEventListener('mousedown', (e)=>{
    if (e.clientX > window.innerWidth * 0.45) {
      lookPointer.down = true; lookPointer.startX = e.clientX; lookPointer.startY = e.clientY;
    }
  });
  window.addEventListener('mousemove', (e)=>{
    if (lookPointer.down) {
      const dx = e.clientX - lookPointer.startX; const dy = e.clientY - lookPointer.startY;
      lookPointer.startX = e.clientX; lookPointer.startY = e.clientY;
      yaw -= dx * 0.0022; pitch -= dy * 0.0020; pitch = Math.max(-1.2, Math.min(0.65, pitch));
    }
  });
  window.addEventListener('mouseup', ()=>{ lookPointer.down = false; });

  // Pointer lock for desktop immersion
  canvas.addEventListener('click', ()=> {
    if (document.pointerLockElement !== canvas && !isMobile()) {
      canvas.requestPointerLock?.();
    }
  });
  document.addEventListener('pointerlockchange', ()=>{
    if (document.pointerLockElement === canvas) {
      document.addEventListener('mousemove', onPointerMove);
    } else {
      document.removeEventListener('mousemove', onPointerMove);
    }
  });
  function onPointerMove(e){
    yaw -= e.movementX * 0.0022; pitch -= e.movementY * 0.0020; pitch = Math.max(-1.2, Math.min(0.65, pitch));
  }

  // Desktop keyboard movement (only when NOT mobile)
  const keys = {};
  window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

  function applyKeyboard() {
    if (isMobile()) return;
    moveState.forward = 0; moveState.right = 0; moveState.running = false;
    if (keys['w'] || keys['arrowup']) moveState.forward = 1;
    if (keys['s'] || keys['arrowdown']) moveState.forward = -1;
    if (keys['a'] || keys['arrowleft']) moveState.right = -1;
    if (keys['d'] || keys['arrowright']) moveState.right = 1;
    if (keys['shift']) moveState.running = true;
  }

  // Collision
  function collide(position) {
    for (const c of treeCollisionSpheres) {
      const dist = Math.hypot(position.x - c.pos.x, position.z - c.pos.z);
      if (dist < (c.r + 0.34)) return true;
    }
    return false;
  }

  const clock = new THREE.Clock();
  let elapsedNight = 0;

  // Animate loop
  function animate() {
    const dt = Math.min(0.05, clock.getDelta());
    applyKeyboard();

    // animate rivers shader time
    const t = clock.elapsedTime;
    if (window._rivers) for (const r of window._rivers){
      if (r.material && r.material.uniforms && r.material.uniforms.time) r.material.uniforms.time.value = t;
    }

    // battery drains while flashlight is on
    if (flashlightOn && currentBattery > 0) {
      currentBattery = Math.max(0, currentBattery - dt);
      if (currentBattery <= 0) { flashlight.visible = false; flashlightOn = false; }
      updateUI();
    }

    // movement
    let forward = moveState.forward;
    let right = moveState.right;
    const spd = (moveState.running ? runSpeed : moveSpeed);
    const dir = new THREE.Vector3();
    dir.x = Math.sin(yaw) * forward + Math.cos(yaw) * right;
    dir.z = -Math.cos(yaw) * forward + Math.sin(yaw) * right;
    if (dir.lengthSq() > 1) dir.normalize();
    const newPos = camera.position.clone();
    newPos.x += dir.x * spd * dt;
    newPos.z += dir.z * spd * dt;
    if (!collide(newPos)) camera.position.copy(newPos);
    camera.position.y = playerHeight;

    camera.rotation.order = "YXZ";
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;

    // flashlight follow
    flashlight.position.copy(camera.position);
    const aim = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).add(camera.position);
    flashlight.target.position.copy(aim);

    // fog intensifies when battery low
    const pct = Math.max(0, Math.min(1, currentBattery / batteryLife));
    scene.fog.density = 0.010 + (1 - pct) * 0.028;

    renderer.render(scene, camera);
    elapsedNight += dt;
    requestAnimationFrame(animate);
  }
  animate();

  // Utils
  function isMobile(){ return /Mobi|Android/i.test(navigator.userAgent); }
  window.addEventListener('resize', onWindowResize);
  function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
  if (!isMobile()) {
    document.getElementById('joystick').style.display = 'none';
    document.getElementById('tip').textContent = 'WASD para mover â€¢ Click para bloquear mouse â€¢ F linterna';
  }

  // Debug reseter
  window.__resetBattery = function(seconds = batteryLife) {
    currentBattery = seconds; flashlight.visible = flashlightOn && currentBattery>0; updateUI();
  };

  // ---------- SHOCK (efecto de calavera) ----------
  const root = document.documentElement;
  const shockOverlay = document.getElementById('shockOverlay');
  const skullEl = document.getElementById('skull');

  let shockTimer = null;
  let shockActive = false;

  function startShock() {
    if (shockActive) return;
    shockActive = true;
    // add class to body to apply grayscale to canvas
    document.body.classList.add('shock-active');
    // show overlay (fade in)
    shockOverlay.style.opacity = '1';
    // animate skull (CSS handles transform)
    skullEl.style.transform = 'scale(1.8)';
    skullEl.style.opacity = '1';
    // optional: small camera shake by perturbing yaw/pitch briefly
    const originalYaw = yaw, originalPitch = pitch;
    let shakeElapsed = 0;
    const shakeDur = 0.9;
    const shake = (dt) => {
      if (!shockActive) return;
      shakeElapsed += dt;
      const factor = Math.max(0, 1 - (shakeElapsed/shakeDur));
      yaw = originalYaw + (Math.random()-0.5) * 0.08 * factor;
      pitch = originalPitch + (Math.random()-0.5) * 0.04 * factor;
      if (shakeElapsed < shakeDur) requestAnimationFrame(()=>shake(clock.getDelta()));
    };
    shake(0);
    // schedule endShock
    setTimeout(endShock, shockDurationMs);
  }

  function endShock() {
    shockActive = false;
    document.body.classList.remove('shock-active');
    skullEl.style.transform = 'scale(0.02)';
    skullEl.style.opacity = '0';
    shockOverlay.style.opacity = '0';
    // slight delay to fully restore
    setTimeout(()=>{}, 400);
  }

  // Start interval
  let shockInterval = setInterval(() => {
    startShock();
  }, shockIntervalMs);

  // allow immediate trigger for testing by calling window.__triggerShock()
  window.__triggerShock = function(){
    startShock();
  };

  // Ensure initial overlay hidden
  shockOverlay.style.opacity = '0';
  skullEl.style.transform = 'scale(0.02)';
  skullEl.style.opacity = '0';

  </script>
</body>
</html>