<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Bosque Oscuro — Demo</title>
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; font-family: Arial, sans-serif; }
    #gameCanvas { width:100%; height:100%; display:block; touch-action:none; }
    /* UI */
    .ui {
      position: absolute; left: 10px; top: 10px; color: #fff; z-index: 20;
      text-shadow: 0 0 8px rgba(0,0,0,0.9);
    }
    #battery {
      width: 160px; height: 18px; background: rgba(255,255,255,0.12); border-radius: 9px; overflow:hidden;
      border: 1px solid rgba(255,255,255,0.08);
    }
    #batteryFill { height:100%; width:100%; background: linear-gradient(90deg,#ffd24a,#ff7a4a); transition: width 0.2s linear; }
    #btnFlash {
      margin-top:8px; display:inline-block; padding:8px 12px; background:rgba(255,255,255,0.06); border-radius:8px; border:1px solid rgba(255,255,255,0.06);
      color:#fff; font-weight:600; user-select:none;
    }
    #message { margin-top:8px; color:#f4f4f4; font-size:13px; opacity:0.9; }
    /* joystick */
    .joystick {
      position: absolute; left: 12px; bottom: 12px; width: 130px; height:130px; z-index:20; touch-action:none;
      display:flex; align-items:center; justify-content:center;
    }
    .joy-base {
      width:120px; height:120px; border-radius:50%; background: rgba(255,255,255,0.04); border: 2px solid rgba(255,255,255,0.06);
      display:flex; align-items:center; justify-content:center;
      position:relative;
    }
    .joy-knob {
      width:56px; height:56px; border-radius:50%; background: rgba(255,255,255,0.08); transform: translate(0,0);
      transition: transform 0.02s linear;
    }
    /* right side instruction area for look touch */
    .look-note { position:absolute; right:12px; bottom:12px; z-index:20; color:#fff; font-size:12px; opacity:0.8; }
    /* battery depleted overlay */
    #darkOverlay {
      position:absolute; inset:0; background: radial-gradient(circle at center, rgba(0,0,0,0) 18%, rgba(0,0,0,0.85) 60%); pointer-events:none; z-index:15;
      opacity:0; transition: opacity 0.5s ease;
    }
    /* small mobile tip */
    #tip { position:absolute; left:50%; transform:translateX(-50%); bottom:140px; color:#fff; z-index:20; font-size:13px; opacity:0.85;}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui">
    <div id="battery">
      <div id="batteryFill"></div>
    </div>
    <div id="btnFlash">Linterna: ON (F)</div>
    <div id="message">Batería restante: <span id="batteryText">30</span>s</div>
  </div>

  <div id="tip">Usa joystick (izq) para moverte y arrastra a la derecha para mirar</div>

  <div class="joystick" id="joystick">
    <div class="joy-base" id="joyBase">
      <div class="joy-knob" id="joyKnob"></div>
    </div>
  </div>

  <div class="look-note">Arrastra aquí para mirar</div>

  <div id="darkOverlay"></div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
  <!-- OrbitControls solo para debug (no habilitado en móvil) -->
  <script>
  // ---------- Config ----------
  const batteryLife = 30.0; // segundos que dura la linterna (cámbialo si quieres)
  const nightDuration = 120.0; // duración total de la noche (puedes usar esto para contar tiempo de juego)
  const treesCount = 180;     // cantidad de árboles en el bosque
  const forestRadius = 120;   // radio del bosque
  const playerHeight = 1.6;
  const moveSpeed = 2.6; // m/s
  const runSpeed = 4.5;
  // ----------------------------

  // Canvas & Renderer
  const canvas = document.getElementById('gameCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000010, 0.012);

  // Camera / Player
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 400);
  camera.position.set(0, playerHeight, 0);

  // Light (ambient moon glow)
  const hemi = new THREE.HemisphereLight(0x40405a, 0x060616, 0.6);
  scene.add(hemi);

  const moon = new THREE.DirectionalLight(0xb9d3ff, 0.12);
  moon.position.set(50, 80, -60);
  scene.add(moon);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(2000,2000,10,10);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x0b120b, roughness:1 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Simple low-poly tree factory
  const treeGroup = new THREE.Group();
  scene.add(treeGroup);
  const treeCollisionSpheres = []; // {pos:Vector3, r:number}

  function makeTree() {
    // trunk
    const trunkGeo = new THREE.CylinderGeometry(0.12, 0.16, 2.0, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color:0x4a2b1b });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 1.0;

    // leaves (cones stacked)
    const leavesMat = new THREE.MeshStandardMaterial({ color: 0x0c2a10, flatShading:true });
    const leaves1 = new THREE.ConeGeometry(1.2, 1.6, 8);
    const l1 = new THREE.Mesh(leaves1, leavesMat); l1.position.y = 2.0; l1.rotation.y = Math.random()*Math.PI;
    const leaves2 = new THREE.ConeGeometry(0.9, 1.2, 8);
    const l2 = new THREE.Mesh(leaves2, leavesMat); l2.position.y = 2.9;

    const tree = new THREE.Group();
    tree.add(trunk, l1, l2);
    return tree;
  }

  // Populate forest
  for (let i=0;i<treesCount;i++){
    const angle = Math.random()*Math.PI*2;
    const r = Math.random()*forestRadius;
    const x = Math.cos(angle)*r;
    const z = Math.sin(angle)*r;
    // avoid near player spawn
    if (Math.hypot(x, z) < 6) continue;
    const t = makeTree();
    t.position.set(x, 0, z);
    const s = 0.8 + Math.random()*0.9;
    t.scale.setScalar(s);
    t.rotation.y = Math.random()*Math.PI*2;
    treeGroup.add(t);
    // collision sphere
    const colRad = 0.9 * s;
    treeCollisionSpheres.push({ pos: new THREE.Vector3(x, 1.0, z), r: colRad });
  }

  // Add some rocks / mushrooms for variety (simple boxes)
  for (let i=0;i<40;i++){
    const b = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.5), new THREE.MeshStandardMaterial({color:0x232323}));
    const ang = Math.random()*Math.PI*2, rr = 6 + Math.random()*forestRadius;
    b.position.set(Math.cos(ang)*rr, 0.15, Math.sin(ang)*rr);
    b.rotation.y = Math.random()*Math.PI;
    const sc = 0.5 + Math.random()*1.1; b.scale.set(sc,sc,sc);
    scene.add(b);
  }

  // Flashlight (spotlight attached to camera)
  const flashlight = new THREE.SpotLight(0xfff3d9, 2.8, 18, Math.PI * 0.36, 0.8, 1);
  flashlight.castShadow = false;
  flashlight.position.copy(camera.position);
  flashlight.target.position.set(0, playerHeight, -1);
  scene.add(flashlight);
  scene.add(flashlight.target);

  // small attenuation ambient for when flashlight off
  let flashlightOn = true;
  let currentBattery = batteryLife;

  // UI Hooks
  const batteryFill = document.getElementById('batteryFill');
  const batteryText = document.getElementById('batteryText');
  const btnFlash = document.getElementById('btnFlash');
  const darkOverlay = document.getElementById('darkOverlay');

  function updateUI(){
    const pct = Math.max(0, Math.min(1, currentBattery / batteryLife));
    batteryFill.style.width = `${Math.round(pct*100)}%`;
    batteryText.textContent = Math.ceil(currentBattery);
    btnFlash.textContent = `Linterna: ${flashlightOn ? 'ON (F)' : 'OFF (F)'}`;
    // overlay opacity increases as battery drains to simulate darkness
    darkOverlay.style.opacity = flashlightOn ? (1 - pct) * 0.95 : 1.0;
  }
  updateUI();

  btnFlash.addEventListener('click', ()=>{
    flashlightOn = !flashlightOn;
    flashlight.visible = flashlightOn && currentBattery > 0;
    updateUI();
  });

  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() === 'f') {
      flashlightOn = !flashlightOn;
      flashlight.visible = flashlightOn && currentBattery > 0;
      updateUI();
    }
  });

  // Player movement state
  const moveState = { forward:0, right:0, running:false };
  let yaw = 0, pitch = 0;

  // Touch joystick left (movement)
  const joyBase = document.getElementById('joyBase');
  const joyKnob = document.getElementById('joyKnob');
  const joy = { active:false, id:null, startX:0, startY:0, dx:0, dy:0 };

  function joyStart(e, touch){
    joy.active = true;
    joy.id = touch.identifier;
    joy.startX = touch.clientX;
    joy.startY = touch.clientY;
    joy.dx = 0; joy.dy = 0;
  }
  function joyMove(touch) {
    const max = 46; // radius for movement
    const dx = touch.clientX - joy.startX;
    const dy = touch.clientY - joy.startY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const clamped = Math.min(max, dist);
    const nx = dx / (dist||1) * clamped;
    const ny = dy / (dist||1) * clamped;
    joy.dx = nx; joy.dy = ny;
    joyKnob.style.transform = `translate(${nx}px, ${ny}px)`;
    // Convert to movement axes (-1..1)
    moveState.forward = -ny / max; // up is negative in screen coords
    moveState.right = nx / max;
  }
  function joyEnd() {
    joy.active = false;
    joy.id = null;
    joy.dx = joy.dy = 0;
    joyKnob.style.transform = `translate(0px, 0px)`;
    moveState.forward = 0; moveState.right = 0;
  }

  // Touch handlers
  window.addEventListener('touchstart', (ev)=>{
    for (const t of ev.changedTouches) {
      if (t.clientX < window.innerWidth * 0.5 && !joy.active) {
        joyStart(ev, t);
      } else {
        // right side touches used for look
        lookPointer.down = true;
        lookPointer.id = t.identifier;
        lookPointer.startX = t.clientX; lookPointer.startY = t.clientY;
      }
    }
  }, {passive:false});

  window.addEventListener('touchmove', (ev)=>{
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (joy.active && t.identifier === joy.id) {
        joyMove(t);
      } else if (lookPointer.id === t.identifier) {
        const dx = t.clientX - lookPointer.startX;
        const dy = t.clientY - lookPointer.startY;
        lookPointer.startX = t.clientX; lookPointer.startY = t.clientY;
        yaw -= dx * 0.0022;
        pitch -= dy * 0.0020;
        pitch = Math.max(-1.2, Math.min(0.65, pitch));
      }
    }
  }, {passive:false});

  window.addEventListener('touchend', (ev)=>{
    for (const t of ev.changedTouches) {
      if (joy.active && t.identifier === joy.id) joyEnd();
      if (lookPointer.id === t.identifier) { lookPointer.down = false; lookPointer.id = null; }
    }
  });

  // Right side: look with mouse drag
  const lookPointer = { down:false, id:null, startX:0, startY:0 };
  window.addEventListener('mousedown', (e)=>{
    if (e.clientX > window.innerWidth * 0.45) {
      lookPointer.down = true;
      lookPointer.startX = e.clientX; lookPointer.startY = e.clientY;
    } else {
      // clicking left could be joystick start on desktop: ignore
    }
  });
  window.addEventListener('mousemove', (e)=>{
    if (lookPointer.down) {
      const dx = e.clientX - lookPointer.startX;
      const dy = e.clientY - lookPointer.startY;
      lookPointer.startX = e.clientX; lookPointer.startY = e.clientY;
      yaw -= dx * 0.0022;
      pitch -= dy * 0.0020;
      pitch = Math.max(-1.2, Math.min(0.65, pitch));
    }
  });
  window.addEventListener('mouseup', ()=>{ lookPointer.down = false; });

  // Pointer lock for immersive desktop (click to lock)
  canvas.addEventListener('click', ()=> {
    if (document.pointerLockElement !== canvas && !isMobile()) {
      canvas.requestPointerLock?.();
    }
  });
  document.addEventListener('pointerlockchange', ()=>{
    if (document.pointerLockElement === canvas) {
      document.addEventListener('mousemove', onPointerMove);
    } else {
      document.removeEventListener('mousemove', onPointerMove);
    }
  });
  function onPointerMove(e){
    yaw -= e.movementX * 0.0022;
    pitch -= e.movementY * 0.0020;
    pitch = Math.max(-1.2, Math.min(0.65, pitch));
  }

  // Desktop keyboard movement
  const keys = {};
  window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

  function applyKeyboard() {
    moveState.forward = 0; moveState.right = 0; moveState.running = false;
    if (keys['w'] || keys['arrowup']) moveState.forward = 1;
    if (keys['s'] || keys['arrowdown']) moveState.forward = -1;
    if (keys['a'] || keys['arrowleft']) moveState.right = -1;
    if (keys['d'] || keys['arrowright']) moveState.right = 1;
    if (keys['shift']) moveState.running = true;
  }

  // Simple collision: test desired new pos against tree spheres
  function collide(position) {
    for (const c of treeCollisionSpheres) {
      const dist = Math.hypot(position.x - c.pos.x, position.z - c.pos.z);
      if (dist < (c.r + 0.3)) {
        return true;
      }
    }
    return false;
  }

  // Clock
  const clock = new THREE.Clock();

  // Audio ambient (placeholder - will work if you add audio files)
  // const listener = new THREE.AudioListener(); camera.add(listener);
  // const ambientSound = new THREE.Audio(listener); // attach buffer if you add

  // Render loop
  let elapsedNight = 0;
  function animate() {
    const dt = Math.min(0.05, clock.getDelta());
    applyKeyboard();

    // update battery if flashlight is on
    if (flashlightOn && currentBattery > 0) {
      currentBattery = Math.max(0, currentBattery - dt);
      if (currentBattery <= 0) {
        flashlight.visible = false;
        flashlightOn = false;
      }
      updateUI();
    }

    // handle movement vector
    let forward = moveState.forward;
    let right = moveState.right;
    const spd = (moveState.running ? runSpeed : moveSpeed) * (1 + 0*0); // leave hook for sprint
    // If joystick, keep values as is (already -1..1)
    // If keyboard, values are ints too
    // Build direction from yaw
    const dir = new THREE.Vector3();
    dir.x = Math.sin(yaw) * forward + Math.cos(yaw) * right;
    dir.z = -Math.cos(yaw) * forward + Math.sin(yaw) * right;
    if (dir.lengthSq() > 1) dir.normalize();

    // Proposed new position
    const newPos = camera.position.clone();
    newPos.x += dir.x * spd * dt;
    newPos.z += dir.z * spd * dt;

    // Collision check (simple)
    if (!collide(newPos)) {
      camera.position.copy(newPos);
    }

    // Keep camera height
    camera.position.y = playerHeight;

    // Apply camera rotation
    camera.rotation.order = "YXZ";
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;

    // Update flashlight position and target
    flashlight.position.copy(camera.position);
    // aim slightly ahead
    const aim = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).add(camera.position);
    flashlight.target.position.copy(aim);

    // Fog / darkness update (slightly intensify when battery low)
    const pct = Math.max(0, Math.min(1, currentBattery / batteryLife));
    scene.fog.density = 0.010 + (1 - pct) * 0.028;

    renderer.render(scene, camera);

    // night timer (not used for rules but could be shown)
    elapsedNight += dt;
    requestAnimationFrame(animate);
  }
  animate();

  // Utils
  function isMobile(){
    return /Mobi|Android/i.test(navigator.userAgent);
  }

  // Resize
  window.addEventListener('resize', onWindowResize);
  function onWindowResize(){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }

  // Small helper: show touch controls only on mobile
  if (!isMobile()) {
    document.getElementById('joystick').style.display = 'none';
    document.getElementById('tip').textContent = 'WASD para mover • Click para bloquear mouse • F linterna';
  }

  // Accessibility: let user reset battery via console (debug)
  window.__resetBattery = function(seconds= batteryLife) {
    currentBattery = seconds;
    flashlight.visible = flashlightOn && currentBattery>0;
    updateUI();
  };
  </script>
</body>
</html>
