<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MiniPlatform — Corregido (Sandbox JS + Controls)</title>
<style>
  html,body{height:100%;margin:0;font-family:Inter, system-ui, Arial;background:#081022;color:#e6eef8}
  #container{position:relative;width:100%;height:100%;overflow:hidden}
  canvas{display:block}

  .panel{position:absolute;background:rgba(0,0,0,0.45);backdrop-filter: blur(4px);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-size:13px}
  #leftPanel{left:12px;top:12px;width:260px;max-height:calc(100% - 24px);overflow:auto}
  #rightPanel{right:12px;top:12px;width:380px;max-height:calc(100% - 24px);overflow:auto}
  #bottomPanel{left:12px;right:12px;bottom:12px;height:140px}

  input,select,button,textarea{font-family:inherit;font-size:13px}
  #playerList{margin-top:8px;max-height:140px;overflow:auto}
  .scriptItem{padding:6px;border-radius:6px;margin-bottom:6px;background:rgba(255,255,255,0.02);display:flex;justify-content:space-between;align-items:center}
  .small{font-size:12px;opacity:0.85}
  #editor{width:100%;height:220px;background:#071021;color:#dff3ff;border:1px solid rgba(255,255,255,0.03);padding:8px;border-radius:6px;resize:vertical}

  .joystick { position: absolute; left:18px; bottom:18px; width:120px; height:120px; border-radius:50%; background: rgba(255,255,255,0.03); pointer-events: auto; touch-action:none }
  .stick { position:absolute; left:50%; top:50%; width:56px; height:56px; margin:-28px 0 0 -28px; border-radius:50%; background: rgba(255,255,255,0.12) }
  .btn { position:absolute; right:18px; bottom:18px; width:64px;height:64px;border-radius:12px;background:rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;pointer-events:auto; }
  .btn:active{transform:scale(0.98)}

  @media(min-width:900px){
    .joystick,.btn{display:none}
  }
</style>
</head>
<body>
<div id="container">
  <!-- UI izquierda: conexión y lista -->
  <div id="leftPanel" class="panel">
    <div><strong>MiniPlatform</strong> — Corregido</div>
    <div style="margin-top:8px">
      <div>Nombre: <input id="nameInput" placeholder="Tu nombre" style="width:130px"/></div>
      <div style="margin-top:6px">
        <button id="connectBtn">Conectar</button>
        <button id="disconnectBtn">Desconectar</button>
      </div>
      <div class="small" style="margin-top:6px">Estado: <span id="status">desconectado</span></div>
    </div>

    <hr style="opacity:0.06"/>

    <div><strong>Jugadores</strong></div>
    <div id="playerList" class="small"></div>

    <hr style="opacity:0.06"/>

    <div><strong>Scripts publicados</strong></div>
    <div id="scriptList" style="margin-top:6px"></div>
  </div>

  <!-- UI derecha: editor y sandbox -->
  <div id="rightPanel" class="panel">
    <div><strong>Editor JS (sandboxed)</strong></div>
    <div class="small" style="margin-top:6px">API permitida: <code>api.log()</code>, <code>api.spawnBox(x,y,z)</code>, <code>api.setPlayerSpeed(n)</code></div>
    <textarea id="editor">// Ejemplo:
api.log('hola desde script');
api.spawnBox(Math.random()*6-3, 1, Math.random()*6-3);
api.setPlayerSpeed(6);</textarea>

    <div style="margin-top:8px;display:flex;gap:8px">
      <button id="runLocalBtn">Ejecutar preview</button>
      <button id="saveScriptBtn">Guardar en Firebase</button>
      <input id="scriptTitle" placeholder="Título" style="flex:1"/>
    </div>

    <div style="margin-top:10px"><strong>Sandbox preview</strong></div>
    <iframe id="sandboxFrame" style="width:100%;height:180px;border-radius:6px;border:1px solid rgba(255,255,255,0.04)" sandbox="allow-scripts"></iframe>
    <div style="margin-top:6px" class="small">Nota: sandbox no tiene acceso al DOM principal ni a Firebase; solo la API permitida.</div>
  </div>

  <!-- Bottom panel -->
  <div id="bottomPanel" class="panel" style="left:12px;right:12px;bottom:12px;display:flex;align-items:center;gap:12px">
    <div>Controles: <span class="small">Desktop: WASD + mouse (click para pointer lock o arrastra para rotar). Móvil: joystick + swipe.</span></div>
    <div style="flex:1"></div>
    <div class="small">FPS: <span id="fps">-</span></div>
  </div>

  <div class="joystick" id="joyArea"><div class="stick" id="stick"></div></div>
  <div class="btn" id="jumpBtn">Saltar</div>
</div>

<!-- Librerías -->
<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

<script>
/* =======================
   CONFIG FIREBASE
   ======================= */
const firebaseConfig = {
  apiKey: "AIzaSyCFQ_geG0HIv2EZ-bfKc97TJNtf2sdqPzc",
  authDomain: "clack-koder.firebaseapp.com",
  databaseURL: "https://clack-koder-default-rtdb.firebaseio.com",
  projectId: "clack-koder",
  storageBucket: "clack-koder.firebasestorage.app",
  messagingSenderId: "478151254938",
  appId: "1:478151254938:web:e2c00e3a5426bd192b9023",
  measurementId: "G-P29ME5Z3S1"
};
firebase.initializeApp(firebaseConfig);
const auth = firebase.auth();
const db = firebase.database();
let localUID = null;

/* =======================
   THREE.JS ESCENA
   ======================= */
const container = document.getElementById('container');
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x88cfe0);

const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0,6,10);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

// luz y suelo
const hemi = new THREE.HemisphereLight(0xffffff,0x666666,0.85); scene.add(hemi);
const dir = new THREE.DirectionalLight(0xffffff,0.6); dir.position.set(10,20,10); scene.add(dir);
const ground = new THREE.Mesh(new THREE.PlaneGeometry(300,300), new THREE.MeshStandardMaterial({color:0x2d7f4d}));
ground.rotation.x = -Math.PI/2; ground.receiveShadow=true; scene.add(ground);

/* helpers: spawn boxes list para limpieza */
const spawnedBoxes = [];

/* Player local */
function makePlayerMesh(color=0x00bbff){
  const g = new THREE.Group();
  const body = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.5,1.6,12), new THREE.MeshStandardMaterial({color}));
  body.position.y = 0.8; g.add(body);
  const head = new THREE.Mesh(new THREE.SphereGeometry(0.45,12,12), new THREE.MeshStandardMaterial({color:0xf2c9b6}));
  head.position.y = 1.7; g.add(head);
  g.position.set(0,0,0);
  return g;
}
const localPlayer = { mesh: makePlayerMesh(0x00ddff), pos: new THREE.Vector3(0,0,0), vel: new THREE.Vector3(0,0,0), rotY:0, speed:4, onGround:true };
scene.add(localPlayer.mesh);

/* Cámara tercera persona */
function updateCamera(){
  const offset = new THREE.Vector3(0,2.4,6).applyAxisAngle(new THREE.Vector3(0,1,0), localPlayer.rotY);
  const targetPos = localPlayer.mesh.position.clone().add(offset);
  camera.position.lerp(targetPos, 0.14);
  camera.lookAt(localPlayer.mesh.position.clone().add(new THREE.Vector3(0,1.2,0)));
}

/* Física simple */
const GRAV = -20;
function physicsStep(dt){
  if(!localPlayer.onGround) localPlayer.vel.y += GRAV * dt;
  localPlayer.mesh.position.add(localPlayer.vel.clone().multiplyScalar(dt));
  if(localPlayer.mesh.position.y <= 0){ localPlayer.mesh.position.y = 0; localPlayer.vel.y = 0; localPlayer.onGround = true; } else localPlayer.onGround = false;
}

/* =======================
   CONTROLES (mouse/touch/joystick)
   ======================= */
let input = { x:0, z:0, jump:false };
const stickEl = document.getElementById('stick'), joyArea = document.getElementById('joyArea');
let joyCenter = {x:0,y:0}, touchId = null;
function startJoy(){ const r = joyArea.getBoundingClientRect(); joyCenter = {x: r.left + r.width/2, y: r.top + r.height/2}; }
startJoy(); addEventListener('resize', startJoy);

function updateStickFromTouch(t){
  const dx = t.clientX - joyCenter.x, dy = t.clientY - joyCenter.y;
  const max = 40;
  const nx = Math.max(-1, Math.min(1, dx / max));
  const ny = Math.max(-1, Math.min(1, dy / max));
  input.x = nx; input.z = -ny;
  stickEl.style.transform = `translate(${nx*30}px, ${ny*30}px)`;
}
function resetStick(){ input.x = 0; input.z = 0; stickEl.style.transform = 'translate(0,0)'; }

joyArea.addEventListener('touchstart', e=>{ e.preventDefault(); const t = e.changedTouches[0]; touchId = t.identifier; updateStickFromTouch(t); });
joyArea.addEventListener('touchmove', e=>{ e.preventDefault(); for(const t of e.changedTouches) if(t.identifier===touchId) { updateStickFromTouch(t); break; }});
joyArea.addEventListener('touchend', e=>{ e.preventDefault(); for(const t of e.changedTouches) if(t.identifier===touchId){ touchId=null; resetStick(); break; }});
document.getElementById('jumpBtn').addEventListener('touchstart', e=>{ e.preventDefault(); input.jump = true; setTimeout(()=> input.jump = false, 150); });

// desktop keyboard
const keys = {}; window.addEventListener('keydown', e=> keys[e.key.toLowerCase()] = true );
window.addEventListener('keyup', e=> keys[e.key.toLowerCase()] = false );

// mouse rotate: pointer lock OR drag
let isPointerLocked = false;
let isDragging = false;
let lastMouseX = 0;

renderer.domElement.addEventListener('click', ()=> {
  // pointer lock on wide screens
  if(window.innerWidth >= 900){
    try { renderer.domElement.requestPointerLock(); } catch(e){}
  }
});
// pointer lock changes
document.addEventListener('pointerlockchange', ()=> { isPointerLocked = !!document.pointerLockElement; });

// mousemove event: either pointer locked or dragging (mousedown -> drag)
document.addEventListener('mousemove', (e)=>{
  if(isPointerLocked){
    const sens = 0.0022;
    localPlayer.rotY -= e.movementX * sens;
  } else if(isDragging){
    const dx = e.clientX - lastMouseX;
    lastMouseX = e.clientX;
    localPlayer.rotY -= dx * 0.006;
  }
});
renderer.domElement.addEventListener('mousedown', (e)=>{
  // start dragging only on left button
  if(e.button === 0 && window.innerWidth >= 900){
    isDragging = true;
    lastMouseX = e.clientX;
  }
});
document.addEventListener('mouseup', ()=> isDragging = false);

// touch swipe rotate for mobile (not joystick)
let lastTouch = null;
document.addEventListener('touchstart', e=> { if(e.touches.length === 1) lastTouch = e.touches[0]; });
document.addEventListener('touchmove', e=> {
  if(e.touches.length === 1 && lastTouch){
    const t = e.touches[0];
    const dx = t.clientX - lastTouch.clientX;
    localPlayer.rotY -= dx * 0.005;
    lastTouch = t;
  }
});
document.addEventListener('touchend', ()=> lastTouch = null);

/* =======================
   GAME LOOP
   ======================= */
let lastTime = performance.now();
let fpsCounter = {last:performance.now(), frames:0};
function loop(t){
  const dt = Math.min(0.05, (t - lastTime) / 1000);
  lastTime = t;

  // keyboard input (desktop)
  if(window.innerWidth >= 900){
    const f = (keys['w']||keys['arrowup'])?1:0;
    const b = (keys['s']||keys['arrowdown'])?1:0;
    const l = (keys['a']||keys['arrowleft'])?1:0;
    const r = (keys['d']||keys['arrowright'])?1:0;
    input.z = f - b;
    input.x = r - l;
    input.jump = !!keys[' '];
  }

  // movement relative to player's yaw
  const move = new THREE.Vector3(input.x, 0, input.z);
  if(move.lengthSq() > 0.0001){
    move.normalize();
    move.applyAxisAngle(new THREE.Vector3(0,1,0), localPlayer.rotY);
    const horiz = new THREE.Vector3(move.x, 0, move.z).multiplyScalar(localPlayer.speed);
    localPlayer.vel.x = THREE.MathUtils.lerp(localPlayer.vel.x, horiz.x, 0.12);
    localPlayer.vel.z = THREE.MathUtils.lerp(localPlayer.vel.z, horiz.z, 0.12);
    // face movement direction smoothly
    const targetAngle = Math.atan2(-move.z, move.x) + Math.PI/2;
    localPlayer.rotY = THREE.MathUtils.lerpAngle(localPlayer.rotY, targetAngle, 0.14);
  } else {
    localPlayer.vel.x = THREE.MathUtils.lerp(localPlayer.vel.x, 0, 0.18);
    localPlayer.vel.z = THREE.MathUtils.lerp(localPlayer.vel.z, 0, 0.18);
  }

  // jump
  if(input.jump && localPlayer.onGround){ localPlayer.vel.y = 6; localPlayer.onGround = false; input.jump = false; }

  physicsStep(dt);

  // update mesh transform
  localPlayer.mesh.rotation.y = localPlayer.rotY;
  updateCamera();

  // render
  renderer.render(scene, camera);

  // fps display
  fpsCounter.frames++;
  if(performance.now() - fpsCounter.last > 500){
    document.getElementById('fps').innerText = Math.round((fpsCounter.frames / ((performance.now() - fpsCounter.last)/1000)));
    fpsCounter.last = performance.now();
    fpsCounter.frames = 0;
  }

  // broadcast to firebase occasionally
  if(localUID && (!localPlayer._lastSent || performance.now() - localPlayer._lastSent > 100)){
    localPlayer._lastSent = performance.now();
    db.ref('players/' + localUID).update({
      x: localPlayer.mesh.position.x,
      y: localPlayer.mesh.position.y,
      z: localPlayer.mesh.position.z,
      ry: localPlayer.rotY,
      updated: firebase.database.ServerValue.TIMESTAMP
    }).catch(()=>{});
  }

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* =======================
   MULTIPLAYER
   ======================= */
const players = {}; // uid -> {mesh}
let playersListener = null;
function makeRemoteMesh(){ return makePlayerMesh(0xffaa00); }

function startPlayersListener(){
  if(playersListener) return;
  playersListener = db.ref('players').on('value', snap=>{
    const data = snap.val() || {};
    // add/update
    for(const uid in data){
      const p = data[uid];
      if(uid === localUID) continue;
      if(!players[uid]){ const m = makeRemoteMesh(); scene.add(m); players[uid] = { mesh:m, last:Date.now(), name: p.name || uid }; }
      const m = players[uid].mesh;
      m.position.x = THREE.MathUtils.lerp(m.position.x, p.x || 0, 0.18);
      m.position.y = THREE.MathUtils.lerp(m.position.y, p.y || 0, 0.12);
      m.position.z = THREE.MathUtils.lerp(m.position.z, p.z || 0, 0.18);
      if(typeof p.ry === 'number') m.rotation.y = THREE.MathUtils.lerp(m.rotation.y, p.ry, 0.12);
      players[uid].last = Date.now();
    }
    // remove missing
    for(const uid in players){ if(!data[uid]){ scene.remove(players[uid].mesh); delete players[uid]; } }
    // UI
    const list = document.getElementById('playerList'); list.innerHTML = '';
    for(const uid in data){ const el = document.createElement('div'); el.innerText = (uid===localUID?'(TÚ) ':'') + (data[uid].name || uid); el.className='small'; list.appendChild(el); }
  });
}
function stopPlayersListener(){
  if(playersListener){ db.ref('players').off('value', playersListener); playersListener = null; for(const uid in players) scene.remove(players[uid].mesh); Object.keys(players).forEach(k=>delete players[k]); }
}

/* =======================
   SANDBOX / EDITOR / SCRIPTS en Firebase
   ======================= */
const editor = document.getElementById('editor');
const sandboxFrame = document.getElementById('sandboxFrame');
const runLocalBtn = document.getElementById('runLocalBtn');
const saveScriptBtn = document.getElementById('saveScriptBtn');
const scriptListEl = document.getElementById('scriptList');
const scriptTitleEl = document.getElementById('scriptTitle');

// crea srcdoc seguro para iframe (envuelve user code)
function makeSandboxSrcdoc(userCode){
  const wrapped = `
  <!doctype html>
  <html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"></head><body style="background:#071025;color:#dff3ff;font-family:monospace">
    <div id="log" style="padding:8px;font-size:12px"></div>
    <script>
      // api para el usuario: api.log, api.spawnBox, api.setPlayerSpeed
      function post(m){ parent.postMessage(m, '*'); }
      window.api = {
        log: function(){ post({type:'log', msg: Array.from(arguments).map(x=>String(x)).join(' ') }); },
        spawnBox: function(x,y,z){ post({type:'api', method:'spawnBox', args:[x,y,z]}); },
        setPlayerSpeed: function(n){ post({type:'api', method:'setPlayerSpeed', args:[n]}); }
      };
      // ejecutar código del usuario (async safe)
      try{
        (async function(){
          ${userCode}
        })().catch(e=> post({type:'log', msg: 'runtime error: ' + (e && e.message ? e.message : e)}));
      }catch(e){
        post({type:'log', msg: 'exec error: ' + (e && e.message ? e.message : e)});
      }
      // recibir logs del host
      window.addEventListener('message', ev => {
        try{
          const d = ev.data || {};
          if(d.type === 'host_log'){ const el = document.getElementById('log'); const p = document.createElement('div'); p.textContent = '[host] ' + d.msg; el.appendChild(p); }
        }catch(_){} 
      });
    <\/script>
  </body></html>
  `;
  return wrapped;
}

// Host: aplicar acciones permitidas desde sandbox
function handleSandboxMessage(event){
  // validar: aceptar SOLO mensajes provenientes del iframe actual
  try{
    const iframeWin = sandboxFrame.contentWindow;
    // event.source might be iframe window; but to be robust check frameElement
    if(!(event.source && (event.source === iframeWin || event.source.frameElement === sandboxFrame))) return;
  }catch(e){
    return;
  }
  const data = event.data || {};
  if(data.type === 'log'){ safeLog('[sandbox] ' + (data.msg || '')); return; }
  if(data.type === 'api'){
    const method = String(data.method || '');
    const args = Array.isArray(data.args) ? data.args : [];
    if(method === 'spawnBox'){
      const x = Number(args[0] || 0), y = Number(args[1] || 1), z = Number(args[2] || 0);
      hostSpawnBox(x,y,z);
      // also inform iframe
      try{ sandboxFrame.contentWindow.postMessage({type:'host_log', msg: 'spawned box at ' + x.toFixed(2)+','+y.toFixed(2)+','+z.toFixed(2)}, '*'); }catch(e){}
    } else if(method === 'setPlayerSpeed'){
      const n = Number(args[0] || localPlayer.speed);
      localPlayer.speed = Math.max(0, Math.min(30, n));
      safeLog('[sandbox] setPlayerSpeed -> ' + localPlayer.speed);
      try{ sandboxFrame.contentWindow.postMessage({type:'host_log', msg: 'setPlayerSpeed -> ' + localPlayer.speed}, '*'); }catch(e){}
    } else {
      safeLog('[sandbox] método NO permitido: ' + method);
    }
  }
}

// host helpers
function safeLog(msg){
  console.log(msg);
  try{ sandboxFrame.contentWindow.postMessage({type:'host_log', msg}, '*'); }catch(e){}
}
function hostSpawnBox(x,y,z){
  const size = 0.9;
  const geo = new THREE.BoxGeometry(size,size,size);
  const mat = new THREE.MeshStandardMaterial({color: Math.random()*0xffffff});
  const m = new THREE.Mesh(geo, mat);
  m.position.set(x,y,z); scene.add(m);
  spawnedBoxes.push(m);
  // remove after 90s
  setTimeout(()=>{ try{ scene.remove(m) }catch(e){} }, 90*1000);
}

// Run preview
runLocalBtn.addEventListener('click', ()=>{
  const code = editor.value || '// vacío';
  sandboxFrame.srcdoc = makeSandboxSrcdoc(code);
  // small focus for mobile
  sandboxFrame.focus();
});

// Save script
saveScriptBtn.addEventListener('click', async ()=>{
  const title = (scriptTitleEl.value || 'Script sin título').slice(0,120);
  const code = editor.value || '';
  if(!code.trim()){ alert('Editor vacío'); return; }
  const meta = { title, code, author: localUID || 'anon', ts: Date.now() };
  const newRef = db.ref('scripts').push();
  await newRef.set(meta);
  alert('Guardado: ' + newRef.key);
});

// Load list of scripts
function loadScriptList(){
  db.ref('scripts').orderByChild('ts').limitToLast(80).on('value', snap=>{
    const data = snap.val() || {};
    scriptListEl.innerHTML = '';
    const arr = Object.keys(data).map(k=>({ id:k, ...data[k] })).sort((a,b)=>b.ts - a.ts);
    arr.forEach(s=>{
      const div = document.createElement('div'); div.className = 'scriptItem';
      const left = document.createElement('div'); left.style.flex = '1';
      const t = document.createElement('div'); t.innerText = s.title; t.style.fontWeight='600';
      const a = document.createElement('div'); a.innerText = 'by '+ (s.author||'anon') + ' • '+ new Date(s.ts).toLocaleString(); a.className='small';
      left.appendChild(t); left.appendChild(a);
      const right = document.createElement('div');
      const runBtn = document.createElement('button'); runBtn.innerText='Run'; runBtn.style.marginRight='6px';
      const forkBtn = document.createElement('button'); forkBtn.innerText='Fork';
      runBtn.addEventListener('click', ()=> { sandboxFrame.srcdoc = makeSandboxSrcdoc(s.code || '// vacío'); sandboxFrame.focus(); });
      forkBtn.addEventListener('click', ()=> { editor.value = s.code || ''; scriptTitleEl.value = s.title + ' (fork)'; window.scrollTo({top:0, behavior:'smooth'}); });
      right.appendChild(runBtn); right.appendChild(forkBtn);
      div.appendChild(left); div.appendChild(right);
      scriptListEl.appendChild(div);
    });
  });
}
loadScriptList();

// listen messages from iframe but validate source
window.addEventListener('message', (ev) => {
  try { handleSandboxMessage(ev); } catch(e){ console.warn('msg handle err', e); }
});

/* =======================
   HOST UI: conectar/desconectar
   ======================= */
document.getElementById('connectBtn').addEventListener('click', async ()=>{
  const name = document.getElementById('nameInput').value || ('Player' + Math.floor(Math.random()*9000+1000));
  try{
    const cred = await auth.signInAnonymously();
    localUID = cred.user.uid;
    await db.ref('players/' + localUID).set({ name, x:0,y:0,z:0, ry:0, updated: firebase.database.ServerValue.TIMESTAMP });
    db.ref('players/' + localUID).onDisconnect().remove();
    document.getElementById('status').innerText = 'conectado: ' + localUID;
    startPlayersListener();
  }catch(e){ console.error(e); document.getElementById('status').innerText = 'error'; }
});
document.getElementById('disconnectBtn').addEventListener('click', async ()=>{
  if(localUID){ await db.ref('players/' + localUID).remove().catch(()=>{}); await auth.signOut(); localUID = null; document.getElementById('status').innerText = 'desconectado'; stopPlayersListener(); }
});

/* =======================
   LIMPIEZA Y UTILIDADES
   ======================= */
renderer.domElement.addEventListener('dblclick', ()=>{ localPlayer.mesh.position.set(Math.random()*6-3, 0, Math.random()*6-3); });
window.addEventListener('beforeunload', ()=>{ if(localUID) db.ref('players/' + localUID).remove().catch(()=>{}); });
setInterval(()=>{ if(spawnedBoxes.length > 40){ const b = spawnedBoxes.shift(); try{ scene.remove(b); }catch(e){} } }, 5000);

</script>
</body>
</html>
