<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Bosque Oscuro — Demo (Actualizado)</title>
  <style>
    html,body { margin:0; height:100%; overflow:hidden; background:#000; font-family: Arial, sans-serif; }
    #gameCanvas { width:100%; height:100%; display:block; touch-action:none; }
    .ui { position: absolute; left: 10px; top: 10px; color: #fff; z-index: 20; text-shadow: 0 0 8px rgba(0,0,0,0.9); }
    #battery { width: 200px; height: 18px; background: rgba(255,255,255,0.12); border-radius: 9px; overflow:hidden; border: 1px solid rgba(255,255,255,0.08); }
    #batteryFill { height:100%; width:100%; background: linear-gradient(90deg,#ffd24a,#ff7a4a); transition: width 0.2s linear; }
    #btnFlash { margin-top:8px; display:inline-block; padding:8px 12px; background:rgba(255,255,255,0.06); border-radius:8px; border:1px solid rgba(255,255,255,0.06); color:#fff; font-weight:600; user-select:none; }
    #message { margin-top:8px; color:#f4f4f4; font-size:13px; opacity:0.95; }
    .joystick { position: absolute; left: 12px; bottom: 12px; width: 130px; height:130px; z-index:20; touch-action:none; display:flex; align-items:center; justify-content:center; }
    .joy-base { width:120px; height:120px; border-radius:50%; background: rgba(255,255,255,0.04); border: 2px solid rgba(255,255,255,0.06); display:flex; align-items:center; justify-content:center; position:relative; }
    .joy-knob { width:56px; height:56px; border-radius:50%; background: rgba(255,255,255,0.08); transform: translate(0,0); transition: transform 0.02s linear; }
    .look-note { position:absolute; right:12px; bottom:12px; z-index:20; color:#fff; font-size:12px; opacity:0.8; }
    #darkOverlay { position:absolute; inset:0; background: radial-gradient(circle at center, rgba(0,0,0,0) 18%, rgba(0,0,0,0.85) 60%); pointer-events:none; z-index:15; opacity:0; transition: opacity 0.5s ease; }
    #tip { position:absolute; left:50%; transform:translateX(-50%); bottom:140px; color:#fff; z-index:20; font-size:13px; opacity:0.85;}
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>

  <div class="ui">
    <div id="battery">
      <div id="batteryFill"></div>
    </div>
    <div id="btnFlash">Linterna: ON (F)</div>
    <div id="message">Batería: <span id="batteryNights">30.0</span> noches · <span id="batteryText">3600</span>s</div>
  </div>

  <div id="tip">Usa joystick (izq) para moverte y arrastra a la derecha para mirar</div>

  <div class="joystick" id="joystick">
    <div class="joy-base" id="joyBase">
      <div class="joy-knob" id="joyKnob"></div>
    </div>
  </div>

  <div class="look-note">Arrastra aquí para mirar</div>
  <div id="darkOverlay"></div>

  <!-- Three.js -->
  <script src="https://unpkg.com/three@0.153.0/build/three.min.js"></script>
  <script>
  // ---------- Config ----------
  const nightDuration = 120.0; // segundos que dura UNA noche
  const batteryLife = nightDuration * 30.0; // ahora dura 30 noches
  const treesCount = 180;
  const forestRadius = 120;
  const playerHeight = 1.6;
  const moveSpeed = 2.8; // m/s
  const runSpeed = 4.6;
  // ----------------------------

  // Canvas & Renderer
  const canvas = document.getElementById('gameCanvas');
  const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000012, 0.012);

  // Camera / Player
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 800);
  camera.position.set(0, playerHeight, 0);

  // Lights
  const hemi = new THREE.HemisphereLight(0x40405a, 0x060616, 0.6);
  scene.add(hemi);

  // Moon (red)
  const moonGeo = new THREE.SphereGeometry(8, 32, 32);
  const moonMat = new THREE.MeshStandardMaterial({ color: 0x330000, emissive: 0x8b0000, emissiveIntensity: 1.8, roughness: 0.8 });
  const moonMesh = new THREE.Mesh(moonGeo, moonMat);
  moonMesh.position.set(-70, 80, -120);
  scene.add(moonMesh);

  // subtle directional light from moon (reddish)
  const moonLight = new THREE.DirectionalLight(0xffb0b0, 0.12);
  moonLight.position.copy(moonMesh.position);
  scene.add(moonLight);

  // Stars (points)
  function makeStars(count=800) {
    const positions = new Float32Array(count * 3);
    const radius = 600;
    for (let i=0;i<count;i++){
      // spherical distribution
      const theta = Math.random() * Math.PI * 2;
      const phi = Math.acos((Math.random()*2)-1);
      const r = radius * (0.9 + Math.random()*0.2);
      const x = Math.sin(phi) * Math.cos(theta) * r;
      const y = Math.sin(phi) * Math.sin(theta) * r;
      const z = Math.cos(phi) * r;
      positions[i*3+0] = x;
      positions[i*3+1] = y + 80; // lift a bit
      positions[i*3+2] = z;
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.9, sizeAttenuation: true, depthWrite: false });
    const pts = new THREE.Points(geom, mat);
    scene.add(pts);
  }
  makeStars(900);

  // Ground
  const groundGeo = new THREE.PlaneGeometry(2000,2000,10,10);
  const groundMat = new THREE.MeshStandardMaterial({ color: 0x07100a, roughness:1 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  scene.add(ground);

  // Trees
  const treeGroup = new THREE.Group();
  scene.add(treeGroup);
  const treeCollisionSpheres = [];

  function makeTree() {
    const trunkGeo = new THREE.CylinderGeometry(0.12, 0.16, 2.0, 6);
    const trunkMat = new THREE.MeshStandardMaterial({ color:0x4a2b1b });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = 1.0;

    const leavesMat = new THREE.MeshStandardMaterial({ color: 0x0c2a10, flatShading:true });
    const leaves1 = new THREE.ConeGeometry(1.2, 1.6, 8);
    const l1 = new THREE.Mesh(leaves1, leavesMat); l1.position.y = 2.0;
    const leaves2 = new THREE.ConeGeometry(0.9, 1.2, 8);
    const l2 = new THREE.Mesh(leaves2, leavesMat); l2.position.y = 2.9;

    const tree = new THREE.Group();
    tree.add(trunk, l1, l2);
    return tree;
  }

  for (let i=0;i<treesCount;i++){
    const angle = Math.random()*Math.PI*2;
    const r = Math.random()*forestRadius;
    const x = Math.cos(angle)*r;
    const z = Math.sin(angle)*r;
    if (Math.hypot(x,z) < 6) continue;
    const t = makeTree();
    t.position.set(x, 0, z);
    const s = 0.8 + Math.random()*0.9;
    t.scale.setScalar(s);
    t.rotation.y = Math.random()*Math.PI*2;
    treeGroup.add(t);
    const colRad = 0.9 * s;
    treeCollisionSpheres.push({ pos: new THREE.Vector3(x, 1.0, z), r: colRad });
  }

  for (let i=0;i<40;i++){
    const b = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.5), new THREE.MeshStandardMaterial({color:0x232323}));
    const ang = Math.random()*Math.PI*2, rr = 6 + Math.random()*forestRadius;
    b.position.set(Math.cos(ang)*rr, 0.15, Math.sin(ang)*rr);
    b.rotation.y = Math.random()*Math.PI;
    const sc = 0.5 + Math.random()*1.1; b.scale.set(sc,sc,sc);
    scene.add(b);
  }

  // Flashlight
  const flashlight = new THREE.SpotLight(0xfff3d9, 3.0, 22, Math.PI * 0.36, 0.9, 1);
  flashlight.position.copy(camera.position);
  flashlight.target.position.set(0, playerHeight, -1);
  scene.add(flashlight);
  scene.add(flashlight.target);

  let flashlightOn = true;
  let currentBattery = batteryLife;

  // UI Hooks
  const batteryFill = document.getElementById('batteryFill');
  const batteryText = document.getElementById('batteryText');
  const batteryNights = document.getElementById('batteryNights');
  const btnFlash = document.getElementById('btnFlash');
  const darkOverlay = document.getElementById('darkOverlay');

  function updateUI(){
    const pct = Math.max(0, Math.min(1, currentBattery / batteryLife));
    batteryFill.style.width = `${Math.round(pct*100)}%`;
    batteryText.textContent = Math.ceil(currentBattery);
    const nightsLeft = (currentBattery / nightDuration);
    batteryNights.textContent = nightsLeft.toFixed(1);
    btnFlash.textContent = `Linterna: ${flashlightOn ? 'ON (F)' : 'OFF (F)'}`;
    darkOverlay.style.opacity = flashlightOn ? (1 - pct) * 0.95 : 1.0;
  }
  updateUI();

  btnFlash.addEventListener('click', ()=>{
    flashlightOn = !flashlightOn;
    flashlight.visible = flashlightOn && currentBattery > 0;
    updateUI();
  });
  window.addEventListener('keydown', (e)=>{
    if (e.key.toLowerCase() === 'f') {
      flashlightOn = !flashlightOn;
      flashlight.visible = flashlightOn && currentBattery > 0;
      updateUI();
    }
  });

  // Movement state
  const moveState = { forward:0, right:0, running:false };
  let yaw = 0, pitch = 0;

  // Joystick
  const joyBase = document.getElementById('joyBase');
  const joyKnob = document.getElementById('joyKnob');
  const joy = { active:false, id:null, startX:0, startY:0, dx:0, dy:0 };
  function joyStart(touch){
    joy.active = true; joy.id = touch.identifier; joy.startX = touch.clientX; joy.startY = touch.clientY; joy.dx = 0; joy.dy = 0;
  }
  function joyMove(touch) {
    const max = 46;
    const dx = touch.clientX - joy.startX;
    const dy = touch.clientY - joy.startY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const clamped = Math.min(max, dist);
    const nx = dx / (dist||1) * clamped;
    const ny = dy / (dist||1) * clamped;
    joy.dx = nx; joy.dy = ny;
    joyKnob.style.transform = `translate(${nx}px, ${ny}px)`;
    // Convert to movement (-1..1)
    moveState.forward = -ny / max;
    moveState.right = nx / max;
  }
  function joyEnd() {
    joy.active = false; joy.id = null; joy.dx = joy.dy = 0; joyKnob.style.transform = `translate(0px, 0px)`; moveState.forward = 0; moveState.right = 0;
  }

  // Touch handlers
  window.addEventListener('touchstart', (ev)=>{
    for (const t of ev.changedTouches) {
      if (t.clientX < window.innerWidth * 0.5 && !joy.active) {
        joyStart(t);
      } else {
        lookPointer.down = true; lookPointer.id = t.identifier; lookPointer.startX = t.clientX; lookPointer.startY = t.clientY;
      }
    }
  }, {passive:false});

  window.addEventListener('touchmove', (ev)=>{
    ev.preventDefault();
    for (const t of ev.changedTouches) {
      if (joy.active && t.identifier === joy.id) {
        joyMove(t);
      } else if (lookPointer.id === t.identifier) {
        const dx = t.clientX - lookPointer.startX; const dy = t.clientY - lookPointer.startY;
        lookPointer.startX = t.clientX; lookPointer.startY = t.clientY;
        yaw -= dx * 0.0022; pitch -= dy * 0.0020; pitch = Math.max(-1.2, Math.min(0.65, pitch));
      }
    }
  }, {passive:false});

  window.addEventListener('touchend', (ev)=>{
    for (const t of ev.changedTouches) {
      if (joy.active && t.identifier === joy.id) joyEnd();
      if (lookPointer.id === t.identifier) { lookPointer.down = false; lookPointer.id = null; }
    }
  });

  // Look pointer for mouse
  const lookPointer = { down:false, id:null, startX:0, startY:0 };
  window.addEventListener('mousedown', (e)=>{
    if (e.clientX > window.innerWidth * 0.45) {
      lookPointer.down = true; lookPointer.startX = e.clientX; lookPointer.startY = e.clientY;
    }
  });
  window.addEventListener('mousemove', (e)=>{
    if (lookPointer.down) {
      const dx = e.clientX - lookPointer.startX; const dy = e.clientY - lookPointer.startY;
      lookPointer.startX = e.clientX; lookPointer.startY = e.clientY;
      yaw -= dx * 0.0022; pitch -= dy * 0.0020; pitch = Math.max(-1.2, Math.min(0.65, pitch));
    }
  });
  window.addEventListener('mouseup', ()=>{ lookPointer.down = false; });

  // Pointer lock for desktop immersion
  canvas.addEventListener('click', ()=> {
    if (document.pointerLockElement !== canvas && !isMobile()) {
      canvas.requestPointerLock?.();
    }
  });
  document.addEventListener('pointerlockchange', ()=>{
    if (document.pointerLockElement === canvas) {
      document.addEventListener('mousemove', onPointerMove);
    } else {
      document.removeEventListener('mousemove', onPointerMove);
    }
  });
  function onPointerMove(e){
    yaw -= e.movementX * 0.0022; pitch -= e.movementY * 0.0020; pitch = Math.max(-1.2, Math.min(0.65, pitch));
  }

  // Desktop keyboard movement (only when NOT mobile)
  const keys = {};
  window.addEventListener('keydown', (e)=>{ keys[e.key.toLowerCase()] = true; });
  window.addEventListener('keyup', (e)=>{ keys[e.key.toLowerCase()] = false; });

  function applyKeyboard() {
    // IMPORTANT: don't override joystick on mobile — only run keyboard logic on desktop
    if (isMobile()) return;
    moveState.forward = 0; moveState.right = 0; moveState.running = false;
    if (keys['w'] || keys['arrowup']) moveState.forward = 1;
    if (keys['s'] || keys['arrowdown']) moveState.forward = -1;
    if (keys['a'] || keys['arrowleft']) moveState.right = -1;
    if (keys['d'] || keys['arrowright']) moveState.right = 1;
    if (keys['shift']) moveState.running = true;
  }

  // Collision
  function collide(position) {
    for (const c of treeCollisionSpheres) {
      const dist = Math.hypot(position.x - c.pos.x, position.z - c.pos.z);
      if (dist < (c.r + 0.34)) return true;
    }
    return false;
  }

  const clock = new THREE.Clock();
  let elapsedNight = 0;

  function animate() {
    const dt = Math.min(0.05, clock.getDelta());
    applyKeyboard();

    // battery drains while flashlight is on
    if (flashlightOn && currentBattery > 0) {
      currentBattery = Math.max(0, currentBattery - dt);
      if (currentBattery <= 0) {
        flashlight.visible = false; flashlightOn = false;
      }
      updateUI();
    }

    // movement
    let forward = moveState.forward;
    let right = moveState.right;
    const spd = (moveState.running ? runSpeed : moveSpeed);
    // build dir from yaw
    const dir = new THREE.Vector3();
    dir.x = Math.sin(yaw) * forward + Math.cos(yaw) * right;
    dir.z = -Math.cos(yaw) * forward + Math.sin(yaw) * right;
    if (dir.lengthSq() > 1) dir.normalize();
    const newPos = camera.position.clone();
    newPos.x += dir.x * spd * dt;
    newPos.z += dir.z * spd * dt;

    if (!collide(newPos)) camera.position.copy(newPos);
    camera.position.y = playerHeight;

    camera.rotation.order = "YXZ";
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;

    // flashlight follow
    flashlight.position.copy(camera.position);
    const aim = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion).add(camera.position);
    flashlight.target.position.copy(aim);

    // fog intensifies when battery low
    const pct = Math.max(0, Math.min(1, currentBattery / batteryLife));
    scene.fog.density = 0.010 + (1 - pct) * 0.028;

    renderer.render(scene, camera);
    elapsedNight += dt;
    requestAnimationFrame(animate);
  }
  animate();

  // Utils
  function isMobile(){ return /Mobi|Android/i.test(navigator.userAgent); }

  // Resize
  window.addEventListener('resize', onWindowResize);
  function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }

  // hide joystick on desktop
  if (!isMobile()) {
    document.getElementById('joystick').style.display = 'none';
    document.getElementById('tip').textContent = 'WASD para mover • Click para bloquear mouse • F linterna';
  }

  // Debug reseter
  window.__resetBattery = function(seconds = batteryLife) {
    currentBattery = seconds; flashlight.visible = flashlightOn && currentBattery>0; updateUI();
  };
  </script>
</body>
</html>